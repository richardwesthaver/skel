#+TITLE: skel
#+DESCRIPTION: project skeletons
* Overview 
+ status :: WIP
+ forge :: [[https://lab.rwest.io/ellis/skel][Heptapod]]
+ mirror :: [[https://github.com/richardwesthaver/skel][Github]]

This system provides functions and macros for building and deploying
project skeletons. /This is not a general purpose templating
system/. It is specifically for my software stack.

** Goals
- vaporize boilerplate code and docs
- integrate reasonably well with my tools (Emacs/etc)
- tree description of projects (nested sexps)
** Resources
- [[https://www.gnu.org/software/emacs/manual/html_node/autotype/Skeleton-Language.html][skeleton-lanaguage (emacs)]]
- [[https://github.com/emacs-mirror/emacs/tree/master/lisp/cedet/ede][cedet/ede (emacs)]]
- [[https://www.gnu.org/software/make/manual/make.html][GNU make]]
- [[https://docs.factorcode.org/content/article-vocabularies.html][Factor (forth) definitions]]
* Quickstart
Make sure you have sbcl installed:
#+begin_src shell :results pp :exports both
sbcl --version
#+end_src

#+RESULTS:
: SBCL 2.3.8.18.master.74-8cf7faf9a

Then compile the program. This command produces a binary called =skel=
in the project root:
#+begin_src shell :results raw silent
sbcl --noinform  --non-interactive --eval '(ql:quickload :skel)' --eval '(asdf:make :skel/cli)'
#+end_src

Run the binary without any args, which will print a skeleton of the
current project directory (=*skel-project*=).

#+begin_src shell :results output replace :exports both
  ./skel -h
#+end_src

#+RESULTS:
#+begin_example
skel v0.1.1
  usage: skel [global] <command> [<arg>]

  A hacker's project compiler and build tool.

  options:
     -h/--help  :  print this message
     -v/--version  :  print version
     -l/--log* :  set log level (debug,info,trace,warn)
     -i/--input  :  input source
     -o/--output  :  output target

  commands:
    status  :  print the status of the current project
    init  :  initialize a skelfile in the current directory
     -n/--name  :  project name
     -k/--kind  :  project kind
    describe  :  describe the project skelfile
     -f/--file  :  path to skelfile
    build  :  build artifacts
     -t/--target  :  target artifact to build
    run  
#+end_example

Here's skel's skelfile:

#+begin_src shell :results output replace :wrap src skel :exports results
cat skelfile
#+end_src

#+RESULTS:
#+begin_src skel
;;; SKEL @ 2023-09-14.01:47:59 --- A hacker's project compiler -*- mode: skel; -*-
:name skel
:version "0.1.0"
:author "Richard Westhaver <ellis@rwest.io>"
:kind :lisp
:description "A hacker's project compiler"
:license "MPL"
:vc (hg :default "https://lab.rwest.io/ellis/skel"
	:mirror (git "https://github.com/richardwesthaver/skel"))
:rules 
((compile () (compile-system :skel))
 (test ("tests.lisp" compile) (quickload :skel/tests) (compile-file $<) (load-file $<) (do-tests :skel))
 ;; TODO 2023-09-22: shell reader macro -- #!(rm -rf *.fasl)
 (clean () (rm -rf *.fasl))
 (debug (compile) (run-sbcl)))
;; TODO 2023-09-22: build-wd 
:scripts 
((yolo () "a yolo commit" 
       (hg-ar ./&) (hg-ci -m yolo) (hg-push) (hg-fe))
 (sxpp (file &optional kind) "Return T if FILE is a valid sxp of type KIND"
       (sxpp kind (read-sxp-file file))))
:snippets nil
:documents ("readme.org")
:stash (:local ".stash" :remote (:hg "https://lab.rwest.io/packy/stash"))
:shed (:local ".shed" :remote (:hg "https://lab.rwest.io/packy/shed"))
:abbrevs 
((isk init-skelfile)
 (dsk describe-skeleton)
 (fsk find-skelfile)
 (lsk load-skelfile)
 (csk compile-skelfile))
:ast (anything you put in here is ignored)
#+end_src

This is just a form without the top-level parentheses - you're free to
omit them in a skelfile.

** describe
The =describe= command can be used to check the currently active
skelfile, printing any errors and the parsed object.

#+begin_src shell :results output replace :exports both
  ./skel describe
#+end_src

#+RESULTS:
#+begin_example
#<SKEL:SK-PROJECT :ID 061e-4558-2d6e-2314>
  [standard-object]

Slots with :INSTANCE allocation:
  NAME                           = SKEL
  PATH                           = "/home/ellis/dev/skel"
  AUTHOR                         = "Richard Westhaver <ellis@rwest.io>"
  VERSION                        = "0.1.0"
  KIND                           = :LISP
  DESCRIPTION                    = "A hacker's project compiler"
  LICENSE                        = "MPL"
  AST                            = NIL
  ID                             = 440866058550518548
  VC                             = (HG :DEFAULT "https://lab.rwest.io/ellis/skel" :MIRROR..
  RULES                          = ((COMPILE NIL (COMPILE-SYSTEM :SKEL))..
  DOCUMENTS                      = ("readme.org")
  SCRIPTS                        = ((YOLO NIL "a yolo commit" (HG-AR ./&) (HG-CI -M YOLO) (HG-PUSH)..
  SNIPPETS                       = NIL
  STASH                          = (:LOCAL ".stash" :REMOTE (:HG "https://lab.rwest.io/packy/stash"))
  SHED                           = (:LOCAL ".shed" :REMOTE (:HG "https://lab.rwest.io/packy/shed"))
  ABBREVS                        = ((ISK INIT-SKELFILE) (DSK DESCRIBE-SKELETON) (FSK FIND-SKELFILE)..
#+end_example
** TODO compile
Skelfiles can be compiled to produce a new project skeleton or update
an existing one.

Try compiling skel's skelfile:

#+begin_src shell :results output replace :exports code
./skel compile
#+end_src

You may also compile individual components of the project structure,
for example, to compile the rules into a makefile:

#+begin_src shell :results output replace :exports code
./skel compile --rules
#+end_src

#+begin_src shell :results output :wrap src makefile :exports both
cat makefile
#+end_src

#+RESULTS:
#+begin_src makefile
### SKEL @ 2023-09-14.01:47:59 --- A hacker's project compiler -*- mode:makefile ; -*-
LISP=sbcl --noinform --non-interactive --eval "(asdf:load-asd \"skel.asd\")" --eval "(ql:quickload :skel)"
.PHONY: compile clean
compile:;$(LISP) --eval "(asdf:compile-system :skel)"
test:compile;$(LISP) --eval "(ql:quickload :skel/tests)" --eval "(in-package :skel.tests)" --eval "(compile-file \"tests.lisp\")" --eval "(load-file \"tests.lisp\")" --eval "(do-tests :skel)"
clean:;rm -rf *.fasl
debug:compile;$(LISP) --eval "(start-repl)"
#+end_src

* Examples
** Default
When you run =skel init= this is the basic skelfile that will be
generated in the current directory, depending on the following
contexts:

- cli args
- user config
- directory contents


With no cli args or user config and an empty directory the output
looks like this:

#+begin_src skel
  ;;; examples @ 2023-09-26.18:15:13 -*- mode: skel; -*-
  (:name "examples"
   :path "/home/ellis/dev/skel/examples")
#+end_src

This is the /canonical/ format of a skel form and is the exact
representation used internally.

You may prefer a less verbose representation for readability and
hacking. To enable /collapsed/ format, add the following to your
=.skelrc= file:

#+begin_src skel
:default-fmt collapsed
#+end_src

Now when you run =skel init= your =skelfile= will look like this:
#+begin_src skel
  ;;; examples @ 2023-09-26.18:15:13 -*- mode: skel; -*-
  :name "examples"
  :path "/home/ellis/dev/skel/examples"
#+end_src

/Whoosh/. no more parens. Well, until you need them rather. The
collapsed format recursively removes outer parens as long as each
top-level element is itself a list.

To override your user-config, you can specify cli args like so:

#+begin_src shell
skel init --vc hg --fmt canonical
#+end_src

#+begin_src skel
  ;;; examples @ 2023-09-26.18:15:13 -*- mode: skel; -*-
  (:name "examples"
   :path "/home/ellis/dev/skel/examples"
   :vc (hg :default nil))
#+end_src

** Lisp
** Rust
** Combo
** Nested
* Tests
The unit tests may also be a useful reference:

#+begin_src lisp :results output replace :wrap src lisp :exports both :package :skel.tests
  ;; (ql:quickload :macs)
  ;; (ql:quickload :skel)
  ;; (ql:quickload :skel/tests)
  (load "tests.lisp")
  (in-package :skel.tests)
  (setq log:*log-level* :debug)
  ;; (setq *catch-test-errors* nil)
  (setq *compile-tests* t)
  (list (multiple-value-list (do-tests :skel)) (test-results *test-suite*))
#+end_src

#+RESULTS:
#+begin_src lisp
in suite SKEL with 4/4 tests:
:DEBUG @ 80423.05 :: running test:  #<TEST VM :fn VM-test16870 :args NIL :persist NIL {100C99F123}> 
:DEBUG @ 80423.055 :: #<PASS (LET ((VM (MAKE-SK-VM 201)))
                               (DOTIMES (I 200) (SKS-POP VM))
                               T)> 
:DEBUG @ 80423.055 :: #<PASS (SKS-POP VM)> 
#<PASS VM-TEST16870> 
:DEBUG @ 80423.055 :: running test:  #<TEST SKELFILES :fn SKELFILES-test16869 :args NIL :persist NIL {100AE3F1A3}> 
:DEBUG @ 80423.06 :: #<PASS (INIT-SKELFILE FILE)> 
:DEBUG @ 80423.06 :: #<PASS (DELETE-FILE FILE)> 
#<PASS SKELFILES-TEST16869> 
:DEBUG @ 80423.06 :: running test:  #<TEST HEADER-COMMENTS :fn HEADER-COMMENTS-test16868 :args NIL :persist NIL {100AE3D9B3}> 
:DEBUG @ 80423.07 :: #<PASS (EQ
                             (TYPE-OF
                              (MAKE-SHEBANG-FILE-HEADER
                               (MAKE-SHEBANG-COMMENT /dev/null)))
                             'FILE-HEADER)> 
:DEBUG @ 80423.07 :: #<PASS (EQ
                             (TYPE-OF
                              (MAKE-SOURCE-FILE-HEADER
                               (MAKE-SOURCE-HEADER-COMMENT foo-test TIMESTAMP T
                                                           DESCRIPTION
                                                           nothing to see here
                                                           OPTS
                                                           '(Definitely-Not_Emacs: T;))))
                             'FILE-HEADER)> 
#<PASS HEADER-COMMENTS-TEST16868> 
:DEBUG @ 80423.07 :: running test:  #<TEST SANITY :fn SANITY-test16867 :args NIL :persist NIL {100AE3B673}> 
:DEBUG @ 80423.08 :: #<PASS (EQ T (APPLY #'/= (SKELS 1000)))> 
#<PASS SANITY-TEST16867> 
No tests failed.
#+end_src

* API
- CLOS-based core classes
- EIEIO-based wrapper classes
#+begin_src dot :file api.svg :exports results
  digraph { splines=true; label="CLOS API"; labelloc="t"; node [shape=record];
    sk [label="(skel :ID :AST)"]
    methods [label="(sk-compile sk-expand sk-build\nsk-run sk-init sk-new sk-save\nsk-tangle sk-weave sk-call sk-print)"]
    skmet [label="(sk-meta :NAME :PATH :VERSION :DESCRIPTION)"]
    skvcs [label="(sk-vc-meta :VC)"]
    skcmd [label="(sk-command)"]
    sktar [label="(sk-target)"]
    sksrc [label="(sk-source)"]
    skrec [label="(sk-recipe :COMMANDS)"]
    skrul [label="(sk-rule :TARGET :SOURCE :RECIPE)"]
    skdoc [label="(sk-document)"]
    skscr [label="(sk-script)"]
    skcfg [label="(sk-config)"]
    sksni [label="(sk-snippet)"]    
    skabb [label="(sk-abbrev)"]
    skpro [label="(sk-project\l:RULES\l:DOCUMENTS\l:SCRIPTS\l:SNIPPETS\l:ABBREVS)\l"]
    sk -> skmet
    skmet -> skvcs
    sk -> skcfg
    sk -> sksni
    sk -> skabb
    sk -> sktar
    sk -> skrul
    sk -> sksrc
    sk -> skcmd
    skvcs -> skpro
    skmet -> skdoc    
    skmet -> skscr    
    skrul -> skpro
    skscr -> skpro
    skdoc -> skpro
    sksni -> skpro
    skabb -> skpro
    sktar -> skrul
    sksrc -> skrul
    skrec -> skrul
    skcmd -> skrec
  }
#+end_src

#+RESULTS:
[[file:api.svg]]
