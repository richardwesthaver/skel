#+TITLE: skel
#+DESCRIPTION: project skeletons
* Overview 
+ status :: WIP
+ forge :: [[https://lab.rwest.io/ellis/skel][Heptapod]]
+ mirror :: [[https://github.com/richardwesthaver/skel][Github]]

This system provides functions and macros for building and deploying
project skeletons. /This is not a general purpose templating
system/. It is specifically for my software stack.

** Goals
- vaporize boilerplate code and docs
- integrate reasonably well with my tools (Emacs/etc)
- tree description of projects (nested sexps)
** Resources
- [[https://www.gnu.org/software/emacs/manual/html_node/autotype/Skeleton-Language.html][skeleton-lanaguage (emacs)]]
- [[https://github.com/emacs-mirror/emacs/tree/master/lisp/cedet/ede][cedet/ede (emacs)]]
- [[https://www.gnu.org/software/make/manual/make.html][GNU make]]
- [[https://docs.factorcode.org/content/article-vocabularies.html][Factor (forth) definitions]]
* Quickstart
Make sure you have sbcl installed:
#+begin_src shell :results pp :exports both
sbcl --version
#+end_src

#+RESULTS:
: SBCL 2.3.8.18.master.74-8cf7faf9a

Then compile the program. This command produces a binary called =skel=
in the project root:
#+begin_src shell :results raw silent
sbcl --noinform  --non-interactive --eval '(ql:quickload :skel)' --eval '(asdf:make :skel/cli)'
#+end_src

Run the binary without any args, which will print a skeleton of the
current project directory (=*skel-project*=).

#+begin_src shell :results output replace :exports both
  ./skel -h
#+end_src

#+RESULTS:
#+begin_example
skel v0.1.1
  usage: skel [global] <command> [<arg>]

  A hacker's project compiler and build tool.

  options:
     -h/--help  :  print this message
     -v/--version  :  print version
     -l/--log* :  set log level (debug,info,trace,warn)
     -i/--input  :  input source
     -o/--output  :  output target

  commands:
    status  :  print the status of the current project
    init  :  initialize a skelfile in the current directory
     -n/--name  :  project name
     -k/--kind  :  project kind
    describe  :  describe the project skelfile
     -f/--file  :  path to skelfile
    build  :  build artifacts
     -t/--target  :  target artifact to build
    run  
#+end_example

Here's skel's skelfile:

#+begin_src shell :results output replace :wrap src skel :exports results
cat skelfile
#+end_src

#+RESULTS:
#+begin_src skel
;;; SKEL @ 2023-09-14.01:47:59 --- A hacker's project compiler -*- mode: skel; -*-
:name skel
:version "0.1.0"
:author "Richard Westhaver <ellis@rwest.io>"
:kind :lisp
:description "A hacker's project compiler"
:license "MPL"
:vc (hg :default "https://lab.rwest.io/ellis/skel"
	:mirror (git "https://github.com/richardwesthaver/skel"))
:rules 
((compile () (compile-system :skel))
 (load () (quickload :skel))
 (test ("tests.lisp" compile load) (compile-file $<) (load-file $<) (do-tests :skel))
 ;; TODO 2023-09-22: shell reader macro -- #!(rm -rf *.fasl)
 (clean () (rm -rf *.fasl))
 (debug (compile load) (run-sbcl)))
:scripts ((yolo () (hg-ar ./&) (hg-ci -m yolo) (hg-push) (hg-fe)))
:snippets nil
:documents ("readme.org")
:stash nil
:shed nil
:abbrevs 
((isk init-skelfile)
 (dsk describe-skeleton)
 (fsk find-skelfile)
 (lsk load-skelfile)
 (csk compile-skelfile))
#+end_src

This is just a form without the top-level parentheses - you're free to
omit them in a skelfile.

#+begin_src shell :results output replace :exports both
  ./skel describe
#+end_src

#+RESULTS:
#+begin_example
#<SKEL:SK-PROJECT :ID 061e-4558-2d6e-2314>
  [standard-object]

Slots with :INSTANCE allocation:
  NAME                           = SKEL
  PATH                           = "/home/ellis/dev/skel"
  AUTHOR                         = "Richard Westhaver <ellis@rwest.io>"
  VERSION                        = "0.1.0"
  KIND                           = :LISP
  DESCRIPTION                    = "A hacker's project compiler"
  LICENSE                        = "MPL"
  AST                            = NIL
  ID                             = 440866058550518548
  VC                             = (HG :DEFAULT "https://lab.rwest.io/ellis/skel" :MIRROR..
  RULES                          = ((COMPILE NIL (COMPILE-SYSTEM :SKEL)) (LOAD NIL (QUICKLOAD :SKEL))..
  DOCUMENTS                      = ("readme.org")
  SCRIPTS                        = ((YOLO NIL (HG-AR ./&) (HG-CI -M YOLO) (HG-PUSH) (HG-FE)))
  SNIPPETS                       = NIL
  STASH                          = NIL
  SHED                           = NIL
  ABBREVS                        = ((ISK INIT-SKELFILE) (DSK DESCRIBE-SKELETON) (FSK FIND-SKELFILE)..
#+end_example
* Examples
** Default
** Lisp
** Rust
** Combo
** Nested
* API
- CLOS-based core classes
- EIEIO-based wrapper classes
#+begin_src dot :file api.svg :exports results
  digraph { splines=true; label="CLOS API"; labelloc="t"; node [shape=record];
    sk [label="(skel :ID :AST)"]
    methods [label="(sk-compile sk-expand sk-build\nsk-run sk-init sk-new sk-save\nsk-tangle sk-weave sk-call sk-print)"]
    skmet [label="(sk-meta :NAME :PATH :VERSION :DESCRIPTION)"]
    skvcs [label="(sk-vc-meta :VC)"]
    skcmd [label="(sk-command)"]
    sktar [label="(sk-target)"]
    sksrc [label="(sk-source)"]
    skrec [label="(sk-recipe :COMMANDS)"]
    skrul [label="(sk-rule :TARGET :SOURCE :RECIPE)"]
    skdoc [label="(sk-document)"]
    skscr [label="(sk-script)"]
    skcfg [label="(sk-config)"]
    sksni [label="(sk-snippet)"]    
    skabb [label="(sk-abbrev)"]
    skpro [label="(sk-project\l:RULES\l:DOCUMENTS\l:SCRIPTS\l:SNIPPETS\l:ABBREVS)\l"]
    sk -> skmet
    skmet -> skvcs
    sk -> skcfg
    sk -> sksni
    sk -> skabb
    sk -> sktar
    sk -> skrul
    sk -> sksrc
    sk -> skcmd
    skvcs -> skpro
    skmet -> skdoc    
    skmet -> skscr    
    skrul -> skpro
    skscr -> skpro
    skdoc -> skpro
    sksni -> skpro
    skabb -> skpro
    sktar -> skrul
    sksrc -> skrul
    skrec -> skrul
    skcmd -> skrec
  }
#+end_src

#+RESULTS:
[[file:api.svg]]
